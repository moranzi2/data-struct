#define  _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
//堆区；malloc创建的
//栈区：函数栈帧
//静态区：static和全区变量
#define N 6
//任何一个树都=根加n颗子树（子树之间不可以相交）
//一个树=根加叶结点加分支节点
//结点的度：一个节点含有的子树的个数为结点的度
//度=0就是叶结点或者终端节点
//度！=0等于分支节点
//父结点(双亲结点)，和子结点(孩子结点)，A->next=B,则A是B的父结点,B是A的子结点
//兄弟结点
//树的度：最大的结点的度
//节点的层次：一层一层，根为第一层
//树的高度或深度：结点的最大层次
//堂兄弟结点，在同一层但又不同父
//祖先结点：从当前结点到根，都是当前结点的祖先
//子孙：某节点下面的树的结点，都是子孙
//森林：多个不相交的树的集合叫森林<并查集>
//struct TreeNode
//{
//	int val;
//	struct TreeNode* chaidArr[6];
//	1.指针数组
//};
//struct TreeNode
//{
//	int val;
//	SeqList childSL;
//	顺序表存储孩子；
//};
struct  TreeNode
{//左孩子右兄弟表示法(自己指向老大，老大带老二，老二带老三....)
	int val;
	struct TreeNode* leftChild;
	struct TreeNode* rightBrother;
};

//二叉树是特殊的树，度最大为2（不是一定为2）
//满二叉树:每一层的结点数都达到最大；
//2^1^2^3^4^5^6^7....满二叉树是一种特殊的完全二叉树
//完全二叉树，前h-1层是满的，最后一层不一定满，但是从左到右必须连续

//对于完全二叉树
//1.二叉树的数组存储(物理上是数组存储)
//leftchild = parent * 2 + 1;
//parent= (child-1)/2;
//2.二叉树的链表存储（非完全二叉树）
// 有序一定是堆，堆不一定有序
//堆：数组数据看作一个完全二叉树（没有其他堆）
//大堆：任意一个父亲大于孩子；
//小堆：任意一个父亲小于孩子；
int main()
{

}